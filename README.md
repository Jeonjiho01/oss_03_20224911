# 리눅스 프로세스 관리 명령어 완전 정복: top, ps, jobs, kill

본 문서는 리눅스/유닉스 시스템에서 프로세스 상태를 **모니터링**하고 **제어**하는 데 사용되는 핵심 명령어인 `top`, `ps`, `jobs`, `kill`에 대한 상세 분석 및 사용법 가이드입니다.

---

## 1. top (실시간 프로세스 모니터링)

`top` 명령어는 시스템의 **실시간** 상태를 대시보드 형태로 표시합니다. CPU 사용률, 메모리 사용량 등이 높은 순서대로 프로세스 목록을 계속 갱신하며 보여줍니다.

> ** 용도:** 서버가 느려졌을 때 **어떤 프로세스가 리소스를 많이 점유하는지** 즉시 찾아낼 때 가장 먼저 사용합니다.

###  사용 예시

```bash
$ top
# (화면이 3초마다 갱신되며 실행 중인 프로세스 목록이 나타납니다.)
# 나가려면 'q'를 누르세요.
```

###  top 실행 중 주요 단축키

실행 중에 다음 키를 입력하여 정렬 기준을 변경하거나 작업을 수행할 수 있습니다.

| 키 | 기능 | 설명 |
| :--- | :--- | :--- |
| **P** | **C**PU 사용률 정렬 | CPU를 많이 쓰는 순서대로 정렬 (기본값) |
| **M** | **M**emory 사용률 정렬 | 메모리를 많이 쓰는 순서대로 정렬 |
| **k** | Kill Process | 특정 프로세스를 종료 (PID 입력 필요) |
| **q** | Quit | `top` 실행 종료 |
| **1** | CPU Core View | 전체 CPU 코어별 사용량을 개별적으로 확인 |

###  주요 표시 정보 (헤더)

| 필드명 | 설명 |
| :--- | :--- |
| **PID** | **P**rocess **ID** (프로세스 고유 식별 번호) |
| **USER** | 프로세스를 실행한 **사용자 계정** |
| **PR / NI** | 프로세스 **우선순위** (Priority / Nice value) |
| **%CPU** | 현재 **CPU 사용 비율** |
| **%MEM** | 현재 **메모리(RAM) 사용 비율** |
| **COMMAND** | 실행 중인 **프로그램 이름** (명령어) |

---

## 2. ps (프로세스 상태 확인)

`ps` 명령어는 특정 시점의 **프로세스 스냅샷**을 출력합니다. `top`이 동영상이라면, `ps`는 **사진**을 찍는 것과 같습니다.

> ** 팁:** 주로 `grep`과 함께 사용하여 **"특정 프로세스가 지금 켜져 있는지"** 확인할 때 가장 많이 쓰입니다.

###  사용 예시

가장 많이 사용되는 두 가지 표준 옵션 스타일입니다.

```bash
# 1. System V 스타일 (가장 보편적)
$ ps -ef | grep python
# 결과: 이름에 'python'이 포함된 모든 프로세스 라인을 출력

# 2. BSD 스타일 (상세 정보 확인 시 선호)
$ ps aux
```

###  자주 사용하는 옵션 조합

| 옵션 조합 | 설명 |
| :--- | :--- |
| **-ef** | **모든 사용자(e)**의 프로세스를 **풀 포맷(f)**으로 출력합니다. (PID와 PPID 확인에 용이) |
| **aux** | **모든 사용자(a, u)**의 프로세스를 **터미널이 없는 것(x)**까지 포함하여 상세히 출력합니다. |
| **-u [계정]** | **특정 사용자**가 실행한 프로세스만 필터링하여 보여줍니다. (예: `ps -u root`) |

###  ps 실행 결과 주요 필드 분석

| 필드 | 의미 | 설명 |
| :--- | :--- | :--- |
| **PID** | Process ID | 프로세스 **고유 번호** (종료 시 이 번호가 필요함) |
| **PPID** | Parent PID | **부모 프로세스**의 ID (누가 이 프로세스를 실행했는가) |
| **UID/USER**| User ID | 프로세스 **소유자** (실행한 사람) |
| **STAT/S** | Status | **R**(실행 중), **S**(대기/Sleep), **Z**(좀비/Zombie), **T**(정지됨) |
| **TIME** | CPU Time | 프로세스가 사용한 **누적 CPU 시간** |
| **CMD** | Command | 실행된 **명령어** 및 **인자값** 전체 |

---

## 3. jobs (백그라운드 작업 관리)

`jobs` 명령어는 **현재 쉘 세션**에서 **백그라운드(Background)**로 돌고 있거나 잠시 멈춘 작업(`Stopped`) 목록을 보여줍니다.

> ** 백그라운드 실행이란?**
> 터미널을 점유하지 않고 뒤에서 조용히 실행되게 하려면 명령어 끝에 `&` 기호를 붙입니다.

###  사용 예시

```bash
# 1. 오래 걸리는 작업을 백그라운드로 실행 (&)
$ sleep 300 &
[1] 12345  <-- [작업번호] PID

# 2. 현재 백그라운드 작업 확인
$ jobs
[1]+  Running                 sleep 300 &

# 3. 백그라운드 작업을 포그라운드(fg)로 가져오기
$ fg %1
```

###  jobs 상태 표시 기호

| 기호/상태 | 설명 |
| :--- | :--- |
| **[N]** | **작업 번호 (Job ID)**. `kill`이나 `fg` 명령 사용 시 `%N`으로 지칭합니다. |
| **+** | **Current Job**. `fg` 입력 시 가장 우선적으로 실행되는 작업입니다. |
| **-** | **Previous Job**. 두 번째로 최근에 접근한 작업입니다. |
| **Running** | 현재 백그라운드에서 **계속 실행 중**인 상태입니다. |
| **Stopped** | **일시 중지**된 상태입니다. (보통 `Ctrl+Z`로 중단됨) |

---

## 4. kill (프로세스 강제 종료)

`kill` 명령어는 특정 **PID**에게 **시그널(Signal)**을 보내 프로세스를 제어합니다. 주로 **응답 없는 프로그램을 강제로 종료**할 때 사용합니다.

* **기본 문법:** `kill [옵션] PID`
* **주의사항:** 종료하려는 **PID**는 `ps` 명령어로 먼저 확인해야 합니다.

###  사용 예시

```bash
# 1. 일반적인 종료 요청 (권장) - 프로그램에게 "종료해"라고 정중히 요청
$ kill 12345

# 2. 강제 종료 (즉시 사살) - 저장 기회 없이 즉시 메모리에서 제거
$ kill -9 12345

# 3. 작업 번호(Job ID)로 종료하기 (jobs 명령어의 번호 사용 시 % 붙임)
$ kill %1
```

###  주요 시그널 종류 (옵션)

| 옵션(번호) | 시그널 이름 | 설명 | 강도 |
| :--- | :--- | :--- | :--- |
| **-15** | **SIGTERM** | (기본값) **정상 종료 요청**. 프로세스가 정리 작업을 마친 후 종료됩니다. | 약함 (안전) |
| **-9** | **SIGKILL** | **강제 종료**. 프로세스의 의사와 상관없이 커널이 **즉시 제거**합니다. | **강함 (위험)** |
| **-2** | **SIGINT** | **인터럽트 시그널**. 키보드 `Ctrl+C`를 누른 것과 동일한 효과입니다. | 보통 |

---

##  요약

리눅스 프로세스 관리는 **`top`으로 실시간 감시**하고, **`ps`로 특정 PID를 조회**한 뒤, **`jobs`로 백그라운드 작업을 확인**하고, 문제가 있다면 **`kill`로 프로세스를 정리**하는 흐름으로 진행됩니다.
